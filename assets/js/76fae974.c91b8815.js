"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4717],{3905:function(e,t,r){r.r(t),r.d(t,{MDXContext:function(){return m},MDXProvider:function(){return d},mdx:function(){return h},useMDXComponents:function(){return u},withMDXComponents:function(){return p}});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},a.apply(this,arguments)}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var m=n.createContext({}),p=function(e){return function(t){var r=u(t.components);return n.createElement(e,a({},t,{components:r}))}},u=function(e){var t=n.useContext(m),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},d=function(e){var t=u(e.components);return n.createElement(m.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=u(r),d=i,f=p["".concat(o,".").concat(d)]||p[d]||c[d]||a;return r?n.createElement(f,s(s({ref:t},m),{},{components:r})):n.createElement(f,s({ref:t},m))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var m=2;m<a;m++)o[m]=r[m];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},17384:function(e,t,r){r.r(t),r.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return c},frontMatter:function(){return s},metadata:function(){return m},toc:function(){return u}});var n=r(83117),i=r(80102),a=(r(67294),r(3905)),o=["components"],s={id:"uniform_metropolis_hastings",title:"Single-Site Uniform Metropolis-Hastings",sidebar_label:"Single-Site Uniform MH",slug:"/uniform_metropolis_hastings"},l=void 0,m={unversionedId:"framework_topics/mcmc_inference/uniform_metropolis_hastings",id:"framework_topics/mcmc_inference/uniform_metropolis_hastings",title:"Single-Site Uniform Metropolis-Hastings",description:"Single-Site Uniform Metropolis-Hastings is used to infer over variables that have discrete support, for example random variables with Bernoulli and Categorical distributions. It is overall very similar to Ancestral Metropolis-Hastings. However, it is designed so that it will even explore discrete samples that are unlikely under the prior distribution.",source:"@site/../docs/framework_topics/mcmc_inference/uniform_metropolis_hastings.md",sourceDirName:"framework_topics/mcmc_inference",slug:"/uniform_metropolis_hastings",permalink:"/docs/uniform_metropolis_hastings",draft:!1,editUrl:"https://github.com/facebookresearch/beanmachine/edit/main/website/../docs/framework_topics/mcmc_inference/uniform_metropolis_hastings.md",tags:[],version:"current",frontMatter:{id:"uniform_metropolis_hastings",title:"Single-Site Uniform Metropolis-Hastings",sidebar_label:"Single-Site Uniform MH",slug:"/uniform_metropolis_hastings"},sidebar:"someSidebar",previous:{title:"Single-Site Random Walk MH",permalink:"/docs/random_walk"},next:{title:"Hamiltonian Monte Carlo",permalink:"/docs/hamiltonian_monte_carlo"}},p={},u=[{value:"Algorithm",id:"algorithm",level:2},{value:"Usage",id:"usage",level:2}],d={toc:u};function c(e){var t=e.components,r=(0,i.Z)(e,o);return(0,a.mdx)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Single-Site Uniform Metropolis-Hastings is used to infer over variables that have discrete support, for example random variables with Bernoulli and Categorical distributions. It is overall very similar to Ancestral Metropolis-Hastings. However, it is designed so that it will even explore discrete samples that are unlikely under the prior distribution."),(0,a.mdx)("h2",{id:"algorithm"},"Algorithm"),(0,a.mdx)("p",null,"The Single-Site Uniform Sampler works very similarly to ",(0,a.mdx)("a",{parentName:"p",href:"/docs/ancestral_metropolis_hastings"},"Single-Site Ancestral Metropolis-Hastings"),". In fact, the only difference arises in Step 1 of that inference method's Algorithm; i.e, in the way that this sampler proposes a new value. The remaining steps are unchanged."),(0,a.mdx)("p",null,"In Single-Site Uniform Metropolis-Hastings, for random variables with discrete support, instead of sampling from the prior, the proposer samples from a distribution which assigns equal probability across all values in support (hence the name, uniform). However, the likelihood of this sample ",(0,a.mdx)("em",{parentName:"p"},"is")," accounted for when computing the ",(0,a.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm#Formal_derivation"},"Metropolis acceptance probability"),". Thus, even though improbable values may be ",(0,a.mdx)("em",{parentName:"p"},"proposed")," more than indicated by the prior, they will not be ",(0,a.mdx)("em",{parentName:"p"},"accepted")," more often than they should according to the posterior."),(0,a.mdx)("p",null,"At first appearance, this sounds undesirable -- why sample an unlikely value in the first place? This arises from the fact that the prior distribution may not be a good reflection of the posterior distribution for a given discrete random variable. A particular value that is unlikely under the prior may, in fact, be quite likely under the posterior. Uniform Metropolis-Hastings ensures that those values have the opportunity to be sampled, and thus can increase sampling efficiency for many problems where the posterior is distant from the prior."),(0,a.mdx)("p",null,"Please note that, if you use this inference method for continuous random variables, it will fall back to Single-Site Ancestral Metropolis-Hastings."),(0,a.mdx)("h2",{id:"usage"},"Usage"),(0,a.mdx)("p",null,"The following code snippet illustrates how to use the inference method."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-py"},"samples = bm.SingleSiteUniformMetropolisHastings().infer(\n    queries,\n    observations,\n    num_samples,\n    num_chains,\n)\n")),(0,a.mdx)("p",null,"The parameters to ",(0,a.mdx)("inlineCode",{parentName:"p"},"infer")," are described below:"),(0,a.mdx)("table",null,(0,a.mdx)("thead",{parentName:"table"},(0,a.mdx)("tr",{parentName:"thead"},(0,a.mdx)("th",{parentName:"tr",align:null},"Name"),(0,a.mdx)("th",{parentName:"tr",align:null},"Usage"))),(0,a.mdx)("tbody",{parentName:"table"},(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"queries")),(0,a.mdx)("td",{parentName:"tr",align:null},"A ",(0,a.mdx)("inlineCode",{parentName:"td"},"List")," of ",(0,a.mdx)("inlineCode",{parentName:"td"},"@bm.random_variable")," targets to fit posterior distributions for.")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"observations")),(0,a.mdx)("td",{parentName:"tr",align:null},"The ",(0,a.mdx)("inlineCode",{parentName:"td"},"Dict")," of observations. Each key is a random variable, and its value is the observed value for that random variable.")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"num_samples")),(0,a.mdx)("td",{parentName:"tr",align:null},"Number of samples to build up distributions for the values listed in ",(0,a.mdx)("inlineCode",{parentName:"td"},"queries"),".")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"num_chains")),(0,a.mdx)("td",{parentName:"tr",align:null},"Number of separate inference runs to use. Multiple chains can be used by diagnostics to verify inference ran correctly.")))))}c.isMDXComponent=!0}}]);